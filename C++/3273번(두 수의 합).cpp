/*
	#### 문제 풀이 TIP ####
	1) 이 문제는 2중 for문을 사용하여 풀게 되면 시간 초과가 발생하게 된다.
	   그래서 더 빠른 문제 풀이가 필요한데
	   여기서 사용한 방법은 투 포인터이다.
	   
	   입력한 값을 vector에 저장하고 맨 왼쪽과 맨 오른쪽의 인덱스 값을 저장할
	   변수를 생성해준다. (아래 코드에서는 l, r이 해당)/
	   
	   목표 값인 x와 v[l]+v[r]의 값이 같으면 카운터를 증가시켜주고
	   l값 증가, r값을 감소 시킨다.

	   x 값보다 v[l]+v[r] 값이 크다면, r값을 감소시키고
	   그 반대일 경우, l값을 증가시켜가며, 합이 x인 원소 쌍을 찾게 된다.

	   주의할 점은 투 포인터 알고리즘을 적용하기 위해서는
	   먼저 오름차순으로 정렬되어 있어야 한다.
*/

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
	int n, x, cnt = 0;			// 수열의 크기 n, 타겟 넘버 x, 원소 쌍의 개수 cnt
	vector<int> v;				// 입력한 정수를 저장할 vector
	cin >> n;					// 수열의 크기 입력


	for (int i = 0; i < n; i++)	// 수열의 크기 만큼 입력 받는다.
	{
		int num;
		cin >> num;
		v.push_back(num);
	}
	cin >> x;					// 타겟 넘버 x 입력

	sort(v.begin(), v.end());	// 투 포인터를 적용하기 위해 벡터를 정렬한다.

	int l = 0, r = n - 1;		// 벡터의 맨 왼쪽과 오른쪽의 인덱스 값을 지정.

	while (true)				// 무한 루프
	{
		if (l >= r)				// l값이 r값보다 크거나 같은경우(원소를 전부 탐색한 경우)
			break;				// 무한루프를 빠져 나간다.
		int sum = v[l] + v[r];	// 맨 처음 원소의 합은 벡터의 맨 오른쪽 값과 왼쪽값으로 초기화.

		if (sum == x)			// v[l] + v[r] 값이 x값과 같은 경우, 목표 값을 찾은 것이므로, 
		{
			cnt++;				// x를 만족하는 원소 쌍의 수 증가
			l++;				// l값 증가
			r--;				// r값 증가
		}

		else if (sum < x)		// 두 원소의 합이 x보다 작은 경우,
			l++;				// 두 원소의 합을 키워야 하므로,l값을 증가.

		else					// 두 원소 합이 x보다 큰 경우,
			r--;				// 두 원소의 합을 줄여야 하므로, r값 감소.
	}
	cout << cnt << "\n";

	return 0;
}